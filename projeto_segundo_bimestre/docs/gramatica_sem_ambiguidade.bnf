# ============================================================
# GRAMÁTICA EBNF - VYTHON (PURA)
# Versão 3.0 - EBNF COM GRUPOS
# ============================================================

# -------------------- PROGRAMA --------------------
<program> ::= <statement>* 'EOF'

# -------------------- STATEMENTS --------------------
<statement> ::= <ifStatement>
              | <whileStatement>
              | <forStatement>
              | <doWhileStatement>
              | <breakStatement>
              | <continueStatement>
              | <defStatement>
              | <expressionStatement>

<expressionStatement> ::= <expression> ';'?

# -------------------- CONTROLE DE FLUXO --------------------
<ifStatement> ::= 'if' <expression> ':' <block> ('else' ':' <block>)?

<whileStatement> ::= 'while' <expression> ':' <block>

<forStatement> ::= 'for' 'IDENTIFIER' 'in' 'range' '(' <range_args> ')' ':' <block>
<range_args> ::= <expression> <range_args_tail>
<range_args_tail> ::= ',' <expression> <range_args_tail2>
<range_args_tail> ::= ε
<range_args_tail2> ::= ',' <expression>
<range_args_tail2> ::= ε

<doWhileStatement> ::= 'do' ':' <block> 'while' <expression> ';'?

<breakStatement> ::= 'break' ';'?

<continueStatement> ::= 'continue' ';'?

<defStatement> ::= 'def' 'IDENTIFIER' '(' <optional_params> ')' ':' '{' <statement_list> '}' <optional_semicolon>
<optional_params> ::= <paramList>
<optional_params> ::= ε

<paramList> ::= 'IDENTIFIER' <param_list_tail>
<param_list_tail> ::= ',' 'IDENTIFIER' <param_list_tail>
<param_list_tail> ::= ε

# -------------------- BLOCOS --------------------
<block> ::= '{' <statement_list> '}'
<block> ::= <statement>

# -------------------- EXPRESSÕES --------------------
# Precedência: 12 níveis

# Nível 0: Assignment (direita)
<expression> ::= <logicalOrExpr> ('=' <expression>)?

# Nível 1: OR lógico
<logicalOrExpr> ::= <logicalAndExpr> ('or' <logicalAndExpr>)*

# Nível 2: AND lógico
<logicalAndExpr> ::= <logicalNotExpr> ('and' <logicalNotExpr>)*

# Nível 3: NOT lógico
<logicalNotExpr> ::= 'not' <logicalNotExpr>
                   | <bitwiseOrExpr>

# Nível 4: OR bitwise
<bitwiseOrExpr> ::= <bitwiseAndExpr> ('|' <bitwiseAndExpr>)*

# Nível 5: AND bitwise
<bitwiseAndExpr> ::= <comparisonExpr> ('&' <comparisonExpr>)*

# Nível 6: Comparação
<comparisonExpr> ::= <additiveExpr> (('==' | '!=' | '<' | '>' | '<=' | '>=') <additiveExpr>)*

# Nível 7: Adição/Subtração
<additiveExpr> ::= <multiplicativeExpr> (('+' | '-') <multiplicativeExpr>)*

# Nível 8: Multiplicação/Divisão/Módulo
<multiplicativeExpr> ::= <powerExpr> (('*' | '/' | '%') <powerExpr>)*

# Nível 9: Potência (direita)
<powerExpr> ::= <unaryExpr> ('**' <powerExpr>)?

# Nível 10: Unário
<unaryExpr> ::= '-' <unaryExpr>
              | <postfixExpr>

# Nível 11: Postfix
<postfixExpr> ::= <primary> ('[' <expression> ']' | '(' (<expression> (',' <expression>)*)? ')')*

# Nível 12: Primários
<primary> ::= 'IDENTIFIER'
            | 'NUMBER'
            | 'STRING'
            | 'True'
            | 'False'
            | '(' <expression> ')'
            | '[' (<expression> (',' <expression>)*)? ']'

# ============================================================
# CARACTERÍSTICAS EBNF:
#
# 1. Usa A* para repetição (zero ou mais)
# 2. Usa A? para opcional (zero ou um)  
# 3. Usa (A | B) para alternativas em grupos
# 4. Usa grupos (...) para agrupar elementos
# 5. NÃO usa produções epsilon explícitas
#
# NOTA: Esta gramática é LL(1) em EBNF puro, mas quando
# expandida para BNF gera conflitos epsilon.
# 
# SOLUÇÃO: Use um parser que suporte EBNF nativamente,
# ou aceite que em BNF puro não é LL(1).
# ============================================================
